@prefix : <urn:example.org:> .
@prefix odrl: <http://www.w3.org/ns/odrl/2/> .
@prefix log: <http://www.w3.org/2000/10/swap/log#> .
@prefix string: <http://www.w3.org/2000/10/swap/string#> .
@prefix list: <http://www.w3.org/2000/10/swap/list#> .

# Check if the policies are valid

(_:Policy _:Permission _:Constraint _:LO _:O _:RO) log:onNegativeSurface {

    # Gather all the metadata of the policy
    _:Policy a odrl:Offer .
    _:Policy odrl:permission _:Permission .
    _:Permission odrl:constraint _:Constraint .

    # This is a logical constraint that is in the policy
    _:Constraint odrl:leftOperand _:LO .
    _:Constraint odrl:operator _:O .
    _:Constraint odrl:rightOperand _:RO .

    () log:onNegativeSurface {
        # Here we execute the logical constraint and make the policy valid
        # when the contraint holds
        () log:onNegativeSurface {
            _:LO _:O _:RO .
            () log:onNegativeSurface {
                _:Constraint :is :Valid .
            } .
        } .
    } .
} .

# Implementation of an odrl:lt checker for dates
(_:Blank _:CurrentDate _:Date) log:onNegativeSurface {
    () log:onQuerySurface {
        odrl:dateTime odrl:lt _:Date .
    } .
    _:Blank :currentDate _:CurrentDate  .
    _:CurrentDate string:lessThan _:Date .
} .

# Implementation of an odrl:gt checker for dates
(_:Blank _:CurrentDate _:Date) log:onNegativeSurface {
    () log:onQuerySurface {
        odrl:dateTime odrl:gt _:Date .
    } .
    _:Blank :currentDate _:CurrentDate  .
    _:CurrentDate string:greaterThan _:Date .
} .

# When all contrains are valid, then the policy is valid
# TODO : This need to be done more elegant without collectAllIn
(_:Policy _:Permission _:C1 _:C2 _:L1 _:L2 _:N1 _:N2 _:Scope) log:onNegativeSurface {
    _:Policy a odrl:Offer .
    _:Policy odrl:permission _:Permission.

    ( () { _:Permission odrl:constraint _:C1 . _:C1 :is :Valid } _:L1 ) log:collectAllIn _:Scope .
    ( () { _:Permission odrl:constraint _:C2  } _:L2 ) log:collectAllIn _:Scope .

    _:L1 list:length _:N1 .
    _:L2 list:length _:N2 .

    () log:onNegativeSurface {
        () log:onNegativeSurface {
            _:N1 log:equalTo _:N2 .
            () log:onNegativeSurface {
                _:Policy :is :Valid .
            } .
        } .
        () log:onNegativeSurface {
            _:N1 log:notEqualTo _:N2 .
            () log:onNegativeSurface {
                _:Policy :is :InValid .
            } .
        } .
    } .
} .

# Show something on the output
(_:S _:P _:O) log:onQuerySurface {
    _:S _:P _:O .
    _:P log:notEqualTo log:onNegativeSurface .
    _:P log:notEqualTo log:onQuerySurface .
    () log:onConstructSurface {
        _:S _:P _:O .
    } .
} .