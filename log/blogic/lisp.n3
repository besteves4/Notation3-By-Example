@prefix : <urn:example:> .
@prefix log: <http://www.w3.org/2000/10/swap/log#> .
@prefix rdf: <http://www.w3.org/1999/02/22-rdf-syntax-ns#> .
@prefix list: <http://www.w3.org/2000/10/swap/list#> .

:Prog1 :value
    (:first 
        (:first 
            (:rest 
                (:and 
                    ({:A a :B } {:C a :D } {:E a :F })
                ) 
            )
        )
    ) .

# Compile
(_:Name _:Prog _:Answer) log:onNegativeSurface {
    _:Name :value _:Prog .

    _:Prog :eval _:Answer .

    () log:onNegativeSurface {
        :test :is _:Answer .
    } .
} .

# X :eval Y
#  X a list (X1 X2 ... XN)
#       where X1 a function
#  Y the result of applying X1 on (X2 .. XN)
(_:L1 _:L2 _:H _:R _:Inner) log:onNegativeSurface {
    () log:onQuerySurface {
        _:L1 :eval _:L2 .
    } .

    _:L1 log:rawType rdf:List .

    # Calculate the H(ead) and R(est
    _:L1 list:first _:H .
    ( (_:H) _:R ) list:append _:L1 .

    _:H log:rawType log:Other .

    # Evaluate first the inner
    _:R _:H _:L2 .
} .

# Return the value when the L1 is not a list
(_:L1 _:L2 _:Type) log:onNegativeSurface {
    () log:onQuerySurface {
        _:L1 :eval _:L2 .
    } .
    _:L1 log:rawType _:Type .
    _:Type log:notEqualTo rdf:List .
    _:L1 log:equalTo _:L2 .
} .

# Reuturn the value when the fist of L1 is not a uri
(_:L1 _:L2 _:H _:R _:Answer _:Type) log:onNegativeSurface {
    () log:onQuerySurface {
        _:L1 :eval _:L2 .
    } .

    _:L1 log:rawType rdf:List .

    # Calculate the H(ead) and R(est)
    _:L1 list:first _:H .
    ( (_:H) _:R ) list:append _:L1 .

    _:H log:rawType _:Type .

    _:Type log:notEqualTo log:Other .

    _:L1 log:equalTo _:L2 .
} .

#############################################################
# "built-ins"                                               #
#############################################################

# :and
(_:L1 _:L2) log:onNegativeSurface {
    () log:onQuerySurface {
        (_:L1) :and _:L2 .
    } .
    _:L1 log:conjunction _:L2 .
} .

# :first
(_:L1 _:L2 _:X) log:onNegativeSurface {
    () log:onQuerySurface {
        (_:L1) :first _:L2 .
    } .
    _:L1 :eval _:X .
    _:X list:first _:L2 .
} .

# :rest
(_:L1 _:X _:L2) log:onNegativeSurface {
    () log:onQuerySurface {
        (_:L1) :rest _:L2 .
    } .
    _:L1 list:first _:X .
    ( (_:X) _:L2 ) list:append _:L1 .
} .

(_:S _:O) log:onQuerySurface {
    _:S :is _:O .
} .

(_:S _:O) log:onQuerySurface {
    _:S :value _:O .
} .